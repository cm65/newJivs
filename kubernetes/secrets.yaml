# NOTE: In production, use Kubernetes Secrets with proper encryption at rest
# and integrate with external secret management (AWS Secrets Manager, Azure Key Vault, etc.)
# Never commit real secrets to version control!

apiVersion: v1
kind: Secret
metadata:
  name: jivs-backend-secrets
  namespace: jivs-platform
type: Opaque
stringData:
  DATABASE_PASSWORD: "REPLACE_WITH_SECURE_PASSWORD"
  JWT_SECRET: "REPLACE_WITH_SECURE_JWT_SECRET_MIN_256_BITS"
  ENCRYPTION_KEY: "REPLACE_WITH_SECURE_ENCRYPTION_KEY"
  REDIS_PASSWORD: "REPLACE_WITH_REDIS_PASSWORD"
  RABBITMQ_PASSWORD: "REPLACE_WITH_RABBITMQ_PASSWORD"
  AWS_ACCESS_KEY: "REPLACE_WITH_AWS_ACCESS_KEY"
  AWS_SECRET_KEY: "REPLACE_WITH_AWS_SECRET_KEY"

---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secrets
  namespace: jivs-platform
type: Opaque
stringData:
  POSTGRES_PASSWORD: "REPLACE_WITH_POSTGRES_PASSWORD"
  REPLICATION_PASSWORD: "REPLACE_WITH_REPLICATION_PASSWORD"

---
apiVersion: v1
kind: Secret
metadata:
  name: redis-secrets
  namespace: jivs-platform
type: Opaque
stringData:
  REDIS_PASSWORD: "REPLACE_WITH_REDIS_PASSWORD"

---
apiVersion: v1
kind: Secret
metadata:
  name: rabbitmq-secrets
  namespace: jivs-platform
type: Opaque
stringData:
  RABBITMQ_DEFAULT_USER: "jivs"
  RABBITMQ_DEFAULT_PASS: "REPLACE_WITH_RABBITMQ_PASSWORD"
  RABBITMQ_ERLANG_COOKIE: "REPLACE_WITH_ERLANG_COOKIE"

---
# TLS Certificate Secret (for HTTPS)
apiVersion: v1
kind: Secret
metadata:
  name: tls-certificate
  namespace: jivs-platform
type: kubernetes.io/tls
data:
  tls.crt: BASE64_ENCODED_CERTIFICATE
  tls.key: BASE64_ENCODED_PRIVATE_KEY
