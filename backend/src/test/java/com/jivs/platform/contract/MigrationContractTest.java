package com.jivs.platform.contract;

import au.com.dius.pact.provider.junit5.HttpTestTarget;
import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;
import au.com.dius.pact.provider.junitsupport.Provider;
import au.com.dius.pact.provider.junitsupport.State;
import au.com.dius.pact.provider.junitsupport.loader.PactFolder;
import au.com.dius.pact.provider.spring.junit5.PactVerificationSpringProvider;
import com.jivs.platform.domain.migration.Migration;
import com.jivs.platform.domain.migration.MigrationPhase;
import com.jivs.platform.domain.migration.MigrationStatus;
import com.jivs.platform.repository.MigrationRepository;
import com.jivs.platform.security.JwtTokenProvider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Optional;
import java.util.UUID;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

/**
 * Contract Test - Provider Side
 *
 * This test verifies that the backend (provider) satisfies the contract
 * defined by the frontend (consumer).
 *
 * It reads the Pact file generated by the frontend tests and verifies
 * that our API responses match what the frontend expects.
 *
 * THIS WOULD HAVE CAUGHT THE MIGRATION BUG!
 * If backend expected different fields than frontend sends, this test would fail.
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Provider("JiVS Backend")
@PactFolder("../frontend/pacts") // Points to frontend's pact files
@ExtendWith(SpringExtension.class)
@ActiveProfiles("test")
public class MigrationContractTest {

    @LocalServerPort
    private int port;

    @Autowired
    private MigrationRepository migrationRepository;

    @MockBean
    private JwtTokenProvider jwtTokenProvider;

    @BeforeEach
    void setup(PactVerificationContext context) {
        // Configure the test to hit our running Spring Boot application
        context.setTarget(new HttpTestTarget("localhost", port));

        // Mock JWT validation for tests
        when(jwtTokenProvider.validateToken(anyString())).thenReturn(true);
        when(jwtTokenProvider.getUserIdFromToken(anyString())).thenReturn(1L);
        when(jwtTokenProvider.getRolesFromToken(anyString())).thenReturn(Collections.singletonList("ROLE_ADMIN"));
    }

    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        // This will run once for each interaction in the pact file
        context.verifyInteraction();
    }

    /**
     * Provider States - Set up test data for different scenarios
     */

    @State("user is authenticated")
    public void authenticatedUser() {
        // In a real scenario, you would set up a test user with JWT
        System.out.println("Setting up: User is authenticated");
        // Authentication is mocked in setup()
    }

    @State("user is authenticated and migrations exist")
    public void authenticatedUserWithMigrations() {
        System.out.println("Setting up: User is authenticated and migrations exist");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create test migrations
        Migration migration1 = new Migration();
        migration1.setName("Test Migration 1");
        migration1.setDescription("Test Description 1");
        migration1.setSourceSystem("Oracle");
        migration1.setTargetSystem("PostgreSQL");
        migration1.setMigrationType("FULL");
        migration1.setStatus(MigrationStatus.RUNNING);
        migration1.setPhase(MigrationPhase.EXTRACTION);
        migration1.setProjectCode("MIG-20251013-00001");
        migration1.setProjectType("FULL");
        migration1.setProgress(45.5);
        migration1.setRecordsMigrated(4500L);
        migration1.setTotalRecords(10000L);
        migration1.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration1);

        Migration migration2 = new Migration();
        migration2.setName("Test Migration 2");
        migration2.setDescription("Test Description 2");
        migration2.setSourceSystem("MySQL");
        migration2.setTargetSystem("MongoDB");
        migration2.setMigrationType("INCREMENTAL");
        migration2.setStatus(MigrationStatus.PENDING);
        migration2.setPhase(MigrationPhase.PLANNING);
        migration2.setProjectCode("MIG-20251013-00002");
        migration2.setProjectType("INCREMENTAL");
        migration2.setProgress(0.0);
        migration2.setRecordsMigrated(0L);
        migration2.setTotalRecords(0L);
        migration2.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration2);
    }

    @State("migration exists in PENDING status")
    public void migrationInPendingStatus() {
        System.out.println("Setting up: Migration exists in PENDING status");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a specific migration with known ID
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440001").toString());
        migration.setName("Pending Migration");
        migration.setDescription("Ready to start");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.PENDING);
        migration.setPhase(MigrationPhase.PLANNING);
        migration.setProjectCode("MIG-20251013-00003");
        migration.setProjectType("FULL");
        migration.setProgress(0.0);
        migration.setRecordsMigrated(0L);
        migration.setTotalRecords(0L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }

    @State("migration exists")
    public void migrationExists() {
        System.out.println("Setting up: Migration exists");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a migration for deletion
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440002").toString());
        migration.setName("Migration to Delete");
        migration.setDescription("Will be deleted");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.PENDING);
        migration.setPhase(MigrationPhase.PLANNING);
        migration.setProjectCode("MIG-20251013-00004");
        migration.setProjectType("FULL");
        migration.setProgress(0.0);
        migration.setRecordsMigrated(0L);
        migration.setTotalRecords(0L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }

    @State("migration exists with details")
    public void migrationExistsWithDetails() {
        System.out.println("Setting up: Migration exists with details");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a detailed migration
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440003").toString());
        migration.setName("Production Migration");
        migration.setDescription("Migrating production data");
        migration.setSourceSystem("Oracle Database 12c");
        migration.setTargetSystem("PostgreSQL 15");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.RUNNING);
        migration.setPhase(MigrationPhase.EXTRACTION);
        migration.setProjectCode("MIG-20251013-00005");
        migration.setProjectType("FULL");
        migration.setProgress(45.0);
        migration.setRecordsMigrated(4500L);
        migration.setTotalRecords(10000L);
        migration.setStartedAt(LocalDateTime.now().minusHours(1));
        migration.setCreatedDate(LocalDateTime.now().minusDays(1));
        migrationRepository.save(migration);
    }

    @State("migration exists in RUNNING status")
    public void migrationInRunningStatus() {
        System.out.println("Setting up: Migration exists in RUNNING status");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a running migration
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440004").toString());
        migration.setName("Active Migration");
        migration.setDescription("Currently running");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.RUNNING);
        migration.setPhase(MigrationPhase.EXTRACTION);
        migration.setProjectCode("MIG-20251013-00006");
        migration.setProjectType("FULL");
        migration.setProgress(30.0);
        migration.setRecordsMigrated(3000L);
        migration.setTotalRecords(10000L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }

    @State("migration exists in PAUSED status")
    public void migrationInPausedStatus() {
        System.out.println("Setting up: Migration exists in PAUSED status");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a paused migration
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440005").toString());
        migration.setName("Paused Migration");
        migration.setDescription("Temporarily paused");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.PAUSED);
        migration.setPhase(MigrationPhase.EXTRACTION);
        migration.setProjectCode("MIG-20251013-00007");
        migration.setProjectType("FULL");
        migration.setProgress(60.0);
        migration.setRecordsMigrated(6000L);
        migration.setTotalRecords(10000L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }

    @State("migration exists in COMPLETED or FAILED status")
    public void migrationInCompletedOrFailedStatus() {
        System.out.println("Setting up: Migration exists in COMPLETED or FAILED status");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a completed migration
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440006").toString());
        migration.setName("Completed Migration");
        migration.setDescription("Successfully completed");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.COMPLETED);
        migration.setPhase(MigrationPhase.CLEANUP);
        migration.setProjectCode("MIG-20251013-00008");
        migration.setProjectType("FULL");
        migration.setProgress(100.0);
        migration.setRecordsMigrated(10000L);
        migration.setTotalRecords(10000L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }

    @State("migration exists with progress")
    public void migrationExistsWithProgress() {
        System.out.println("Setting up: Migration exists with progress");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a migration with progress
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440007").toString());
        migration.setName("Progress Migration");
        migration.setDescription("Migration with progress");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.RUNNING);
        migration.setPhase(MigrationPhase.EXTRACTION);
        migration.setProjectCode("MIG-20251013-00009");
        migration.setProjectType("FULL");
        migration.setProgress(55.0);
        migration.setRecordsMigrated(5500L);
        migration.setTotalRecords(10000L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }

    @State("migration exists with statistics")
    public void migrationExistsWithStatistics() {
        System.out.println("Setting up: Migration exists with statistics");

        // Clear existing data
        migrationRepository.deleteAll();

        // Create a migration with statistics
        Migration migration = new Migration();
        migration.setId(UUID.fromString("550e8400-e29b-41d4-a716-446655440008").toString());
        migration.setName("Statistical Migration");
        migration.setDescription("Migration with statistics");
        migration.setSourceSystem("Oracle");
        migration.setTargetSystem("PostgreSQL");
        migration.setMigrationType("FULL");
        migration.setStatus(MigrationStatus.RUNNING);
        migration.setPhase(MigrationPhase.LOADING);
        migration.setProjectCode("MIG-20251013-00010");
        migration.setProjectType("FULL");
        migration.setProgress(75.0);
        migration.setRecordsMigrated(7500L);
        migration.setTotalRecords(10000L);
        migration.setCreatedDate(LocalDateTime.now());
        migrationRepository.save(migration);
    }
}

/**
 * HOW THIS PREVENTS BUGS:
 *
 * 1. Frontend defines contract: "I will send { name, sourceSystem, targetSystem, migrationType }"
 * 2. This test verifies backend accepts exactly those fields
 * 3. If backend expected { name, sourceConfig, targetConfig }, test would FAIL
 *
 * The migration bug would have been caught here with error:
 *   "Backend expects sourceConfig but contract specifies sourceSystem"
 *
 * Benefits:
 * - Catches API contract mismatches immediately (seconds, not hours)
 * - No need for manual testing
 * - Clear error messages showing exactly what's wrong
 * - Runs automatically in CI/CD pipeline
 * - Prevents breaking changes from reaching production
 */