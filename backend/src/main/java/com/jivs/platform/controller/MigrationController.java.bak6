package com.jivs.platform.controller;

import com.jivs.platform.domain.migration.MigrationProject;
import com.jivs.platform.domain.migration.MigrationMetrics;
import com.jivs.platform.dto.BulkActionRequest;
import com.jivs.platform.dto.BulkActionResponse;
import com.jivs.platform.repository.MigrationProjectRepository;
import com.jivs.platform.security.UserPrincipal;
import com.jivs.platform.service.migration.MigrationModels;
import com.jivs.platform.service.migration.MigrationOrchestrator;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.*;

/**
 * REST API controller for data migration operations
 * NOW FULLY INTEGRATED WITH REAL DATABASE PERSISTENCE!
 */
@RestController
@RequestMapping("/api/v1/migrations")
@RequiredArgsConstructor
@CrossOrigin(origins = "*", maxAge = 3600)
public class MigrationController {

    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(MigrationController.class);

    private final MigrationOrchestrator migrationOrchestrator;
    private final MigrationProjectRepository migrationRepository;

    /**
     * Create a new migration job
     * ✅ NOW PERSISTS TO DATABASE!
     */
    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER')")
    public ResponseEntity<Map<String, Object>> createMigration(
            @Valid @RequestBody Map<String, Object> request) {

        log.info("Creating new migration: {}", request.get("name"));

        try {
            String username = getCurrentUsername();

            // Build MigrationRequest from UI input
            MigrationModels.MigrationRequest migrationRequest = new MigrationModels.MigrationRequest();
            migrationRequest.setName((String) request.get("name"));
            migrationRequest.setDescription((String) request.get("description"));
            migrationRequest.setSourceSystem((String) request.get("sourceSystem"));
            migrationRequest.setTargetSystem((String) request.get("targetSystem"));
            migrationRequest.setMigrationType((String) request.get("migrationType"));
            migrationRequest.setUserId(getCurrentUserId());

            @SuppressWarnings("unchecked")
            Map<String, Object> params = (Map<String, Object>) request.get("parameters");
            if (params != null) {
                migrationRequest.setParameters(params);
            }

            // Set optional parameters
            if (request.containsKey("batchSize")) {
                migrationRequest.setBatchSize(((Number) request.get("batchSize")).intValue());
            }
            if (request.containsKey("parallelism")) {
                migrationRequest.setParallelism(((Number) request.get("parallelism")).intValue());
            }

            // Create migration in database
            MigrationProject migration = migrationOrchestrator.initiateMigration(migrationRequest);

            Map<String, Object> response = new HashMap<>();
            response.put("id", migration.getId().toString());
            response.put("name", migration.getName());
            response.put("status", migration.getStatus().toString());
            response.put("phase", migration.getCurrentPhase().toString());
            response.put("createdAt", migration.getCreatedDate());

            return ResponseEntity.status(HttpStatus.CREATED).body(response);

        } catch (Exception e) {
            log.error("Failed to create migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Get migration by ID
     * ✅ NOW READS FROM DATABASE!
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER', 'VIEWER')")
    @org.springframework.transaction.annotation.Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getMigration(@PathVariable Long id) {
        log.info("Getting migration: {}", id);

        try {
            MigrationProject migration = migrationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Migration not found: " + id));

            Map<String, Object> response = new HashMap<>();
            response.put("id", migration.getId().toString());
            response.put("name", migration.getName());
            response.put("status", migration.getStatus().toString());
            response.put("phase", migration.getCurrentPhase().toString());
            response.put("sourceSystem", migration.getSourceSystem());
            response.put("targetSystem", migration.getTargetSystem());

            // Calculate progress
            MigrationMetrics metrics = migration.getMetrics();
            if (metrics != null && metrics.getTotalRecords() > 0) {
                int progress = (int) ((metrics.getProcessedRecords() * 100.0) / metrics.getTotalRecords());
                response.put("progress", Math.min(100, Math.max(0, progress)));
                response.put("recordsMigrated", metrics.getProcessedRecords());
                response.put("totalRecords", metrics.getTotalRecords());
            } else {
                response.put("progress", 0);
                response.put("recordsMigrated", 0);
                response.put("totalRecords", 0);
            }

            response.put("createdAt", migration.getCreatedDate());
            response.put("startTime", migration.getStartTime());
            response.put("completionTime", migration.getCompletionTime());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .body(Map.of("error", "Migration not found"));
        }
    }

    /**
     * List all migrations
     * ✅ NOW READS FROM DATABASE!
     */
    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER', 'VIEWER')")
    @org.springframework.transaction.annotation.Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> listMigrations(
            @RequestParam(required = false, defaultValue = "0") int page,
            @RequestParam(required = false, defaultValue = "20") int size,
            @RequestParam(required = false) String status) {

        log.info("Listing migrations: page={}, size={}, status={}", page, size, status);

        try {
            Page<MigrationProject> migrationPage = migrationRepository.findAll(PageRequest.of(page, size));

            List<Map<String, Object>> migrations = new ArrayList<>();
            for (MigrationProject migration : migrationPage.getContent()) {
                Map<String, Object> migrationData = new HashMap<>();
                migrationData.put("id", migration.getId().toString());
                migrationData.put("name", migration.getName());
                migrationData.put("status", migration.getStatus().toString());
                migrationData.put("phase", migration.getCurrentPhase().toString());

                // Calculate progress
                MigrationMetrics metrics = migration.getMetrics();
                if (metrics != null && metrics.getTotalRecords() > 0) {
                    int progress = (int) ((metrics.getProcessedRecords() * 100.0) / metrics.getTotalRecords());
                    migrationData.put("progress", Math.min(100, Math.max(0, progress)));
                    migrationData.put("recordsMigrated", metrics.getProcessedRecords());
                    migrationData.put("totalRecords", metrics.getTotalRecords());
                } else {
                    migrationData.put("progress", 0);
                    migrationData.put("recordsMigrated", 0);
                    migrationData.put("totalRecords", 0);
                }

                migrationData.put("createdAt", migration.getCreatedDate());
                migrations.add(migrationData);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("content", migrations);
            response.put("totalElements", migrationPage.getTotalElements());
            response.put("totalPages", migrationPage.getTotalPages());
            response.put("currentPage", page);
            response.put("pageSize", size);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to list migrations: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Start a migration job
     * ✅ NOW EXECUTES VIA ORCHESTRATOR!
     */
    @PostMapping("/{id}/start")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER')")
    public ResponseEntity<Map<String, Object>> startMigration(@PathVariable Long id) {
        log.info("Starting migration: {}", id);

        try {
            // Execute migration asynchronously
            migrationOrchestrator.executeMigration(id);

            Map<String, Object> response = new HashMap<>();
            response.put("id", id.toString());
            response.put("status", "RUNNING");
            response.put("message", "Migration started successfully");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to start migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Pause a migration job
     * ✅ NOW UPDATES DATABASE!
     */
    @PostMapping("/{id}/pause")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER')")
    public ResponseEntity<Map<String, Object>> pauseMigration(@PathVariable Long id) {
        log.info("Pausing migration: {}", id);

        try {
            MigrationProject migration = migrationOrchestrator.pauseMigration(id);

            Map<String, Object> response = new HashMap<>();
            response.put("id", migration.getId().toString());
            response.put("status", migration.getStatus().toString());
            response.put("message", "Migration paused successfully");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to pause migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Resume a migration job
     * ✅ NOW UPDATES DATABASE!
     */
    @PostMapping("/{id}/resume")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER')")
    public ResponseEntity<Map<String, Object>> resumeMigration(@PathVariable Long id) {
        log.info("Resuming migration: {}", id);

        try {
            MigrationProject migration = migrationOrchestrator.resumeMigration(id);

            Map<String, Object> response = new HashMap<>();
            response.put("id", migration.getId().toString());
            response.put("status", migration.getStatus().toString());
            response.put("message", "Migration resumed successfully");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to resume migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Rollback a migration
     * ✅ NOW EXECUTES VIA ORCHESTRATOR!
     */
    @PostMapping("/{id}/rollback")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> rollbackMigration(@PathVariable Long id) {
        log.info("Rolling back migration: {}", id);

        try {
            MigrationProject migration = migrationOrchestrator.cancelMigration(id);

            Map<String, Object> response = new HashMap<>();
            response.put("id", migration.getId().toString());
            response.put("status", migration.getStatus().toString());
            response.put("message", "Migration rollback initiated");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to rollback migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Delete a migration job
     * ✅ NOW DELETES FROM DATABASE!
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> deleteMigration(@PathVariable Long id) {
        log.info("Deleting migration: {}", id);

        try {
            migrationRepository.deleteById(id);

            Map<String, Object> response = new HashMap<>();
            response.put("message", "Migration deleted successfully");

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to delete migration: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Perform bulk action on multiple migrations
     * ✅ NOW USES REAL SERVICES!
     */
    @PostMapping("/bulk")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER')")
    public ResponseEntity<BulkActionResponse> bulkAction(@Valid @RequestBody BulkActionRequest request) {
        log.info("Performing bulk action '{}' on {} migrations", request.getAction(), request.getIds().size());

        long startTime = System.currentTimeMillis();

        try {
            List<String> successfulIds = new ArrayList<>();
            Map<String, String> failedIds = new HashMap<>();

            for (String idStr : request.getIds()) {
                try {
                    Long id = Long.parseLong(idStr);

                    switch (request.getAction().toLowerCase()) {
                        case "start":
                            migrationOrchestrator.executeMigration(id);
                            successfulIds.add(idStr);
                            break;

                        case "pause":
                            migrationOrchestrator.pauseMigration(id);
                            successfulIds.add(idStr);
                            break;

                        case "resume":
                            migrationOrchestrator.resumeMigration(id);
                            successfulIds.add(idStr);
                            break;

                        case "delete":
                            migrationRepository.deleteById(id);
                            successfulIds.add(idStr);
                            break;

                        default:
                            failedIds.put(idStr, "Unknown action: " + request.getAction());
                    }
                } catch (Exception e) {
                    log.error("Failed to {} migration {}: {}", request.getAction(), idStr, e.getMessage());
                    failedIds.put(idStr, e.getMessage());
                }
            }

            long processingTime = System.currentTimeMillis() - startTime;

            BulkActionResponse response = BulkActionResponse.builder()
                .status(failedIds.isEmpty() ? "success" : (successfulIds.isEmpty() ? "failed" : "partial"))
                .totalProcessed(request.getIds().size())
                .successCount(successfulIds.size())
                .failureCount(failedIds.size())
                .successfulIds(successfulIds)
                .failedIds(failedIds)
                .message(String.format("Processed %d migrations: %d succeeded, %d failed",
                    request.getIds().size(), successfulIds.size(), failedIds.size()))
                .processingTimeMs(processingTime)
                .build();

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Bulk action failed: {}", e.getMessage(), e);

            BulkActionResponse errorResponse = BulkActionResponse.builder()
                .status("failed")
                .totalProcessed(0)
                .successCount(0)
                .failureCount(request.getIds().size())
                .message("Bulk action failed: " + e.getMessage())
                .processingTimeMs(System.currentTimeMillis() - startTime)
                .build();

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }
    }

    /**
     * Get migration progress
     * ✅ NOW READS FROM DATABASE!
     */
    @GetMapping("/{id}/progress")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER', 'VIEWER')")
    public ResponseEntity<Map<String, Object>> getProgress(@PathVariable Long id) {
        log.info("Getting migration progress: {}", id);

        try {
            MigrationModels.MigrationProgress progress = migrationOrchestrator.getProgress(id);

            Map<String, Object> response = new HashMap<>();
            response.put("overallProgress", progress.getPercentageComplete());
            response.put("currentPhase", progress.getCurrentPhase());
            response.put("recordsMigrated", progress.getProcessedRecords());
            response.put("totalRecords", progress.getTotalRecords());
            response.put("estimatedTimeRemaining", progress.getEstimatedTimeRemaining());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Failed to get progress: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Get migration statistics
     * ✅ NOW READS FROM DATABASE!
     */
    @GetMapping("/{id}/statistics")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER', 'VIEWER')")
    @org.springframework.transaction.annotation.Transactional(readOnly = true)
    public ResponseEntity<Map<String, Object>> getStatistics(@PathVariable Long id) {
        log.info("Getting migration statistics: {}", id);

        try {
            MigrationProject migration = migrationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Migration not found: " + id));

            MigrationMetrics metrics = migration.getMetrics();
            Map<String, Object> stats = new HashMap<>();

            if (metrics != null) {
                stats.put("recordsMigrated", metrics.getProcessedRecords());
                stats.put("recordsFailed", metrics.getFailedRecords());
                stats.put("successfulRecords", metrics.getSuccessfulRecords());
                stats.put("totalRecords", metrics.getTotalRecords());
            } else {
                stats.put("recordsMigrated", 0);
                stats.put("recordsFailed", 0);
                stats.put("successfulRecords", 0);
                stats.put("totalRecords", 0);
            }

            // Calculate duration if started
            if (migration.getStartTime() != null) {
                long durationSeconds;
                if (migration.getCompletionTime() != null) {
                    durationSeconds = java.time.Duration.between(
                        migration.getStartTime(), migration.getCompletionTime()
                    ).getSeconds();
                } else {
                    durationSeconds = java.time.Duration.between(
                        migration.getStartTime(), java.time.LocalDateTime.now()
                    ).getSeconds();
                }
                stats.put("duration", durationSeconds);

                if (metrics != null && durationSeconds > 0) {
                    double throughput = metrics.getProcessedRecords() / (double) durationSeconds;
                    stats.put("throughput", Math.round(throughput * 100.0) / 100.0);
                }
            }

            return ResponseEntity.ok(stats);

        } catch (Exception e) {
            log.error("Failed to get statistics: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Validate migration configuration
     */
    @PostMapping("/validate")
    @PreAuthorize("hasAnyRole('ADMIN', 'DATA_ENGINEER')")
    public ResponseEntity<Map<String, Object>> validateMigration(
            @Valid @RequestBody Map<String, Object> migrationConfig) {

        log.info("Validating migration configuration");

        try {
            // TODO: Implement validation logic
            Map<String, Object> response = new HashMap<>();
            response.put("valid", true);
            response.put("warnings", new ArrayList<String>());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Validation failed: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(Map.of("valid", false, "error", e.getMessage()));
        }
    }

    /**
     * Get current authenticated username
     */
    private String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof UserPrincipal) {
            return ((UserPrincipal) authentication.getPrincipal()).getUsername();
        }
        return "system";
    }

    /**
     * Get current authenticated user ID
     */
    private Long getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof UserPrincipal) {
            return ((UserPrincipal) authentication.getPrincipal()).getId();
        }
        return null;
    }
}
